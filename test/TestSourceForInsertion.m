% Copyright (c) 2012 Physion Consulting LLC

classdef TestSourceForInsertion < MatlabTestCase
    
    methods
        function self = TestSourceForInsertion(name)
            self = self@MatlabTestCase(name);
        end
        
        function testCreatesNewSource(self)
            context = self.context;
            import ovation.*;
            label = ['TestSourceForInsertionCreatesNewSource' num2str(rand)];
            identifier = num2str(rand());
            
            sLength = length(asarray(context.getSourcesWithLabel(label)));
            
            [source,isNew] = sourceForInsertion(context, {label}, {identifier},...
                [],...
                [],...
                datetime(),...
                datetime(),...
                [],...
                []);
            
            assert(isNew);
            assertEqual(label, char(source.getLabel()));
            assertEqual(identifier, char(source.getIdentifier()));
            assertEqual(sLength + 1, length(asarray(context.getSourcesWithLabel(label))));
            
        end
        
        function testCreatesExistingLabelledSource(self)
            context = self.context;
            import ovation.*;
            label = 'TestSourceForInsertionReturnsExistingSingleLabeledSource';
            identifier = 'TestSourceForInsertionReturnsExistingSingleLabeledSource';
            
            [expected,~] = sourceForInsertion(context, {label}, {identifier},...
                [],...
                [],...
                datetime(),...
                datetime(),...
                [],...
                []);
            
            
            [actual,isNew] = sourceForInsertion(context, {expected}, {identifier},...
                [],...
                [],...
                datetime(),...
                datetime(),...
                [],...
                []);
            
            assert(~isNew);
            assert(strcmp(expected.getUuid, actual.getUuid));
            
            
            [~,isNew] = sourceForInsertion(context, {label}, {'foo'},...
                [],...
                [],...
                datetime(),...
                datetime(),...
                [],...
                []);
            
            assert(isNew);
        end
        
        function testSelectsExistingNestedSources(self)
            context = self.context;
            import ovation.*;
            
            project = context.insertProject('unused', 'unused', datetime());
            experiment = project.insertExperiment('unused', datetime());
            protocol = context.insertProtocol('unused', 'unused');
            
            label1 = 'p1';
            id1 = 'id1';
            p1 = context.insertSource(label1, id1);
            
            p1.insertSource(experiment,...
                datetime(),...
                datetime(),...
                protocol,...
                struct2map(struct()),...
                com.google.common.base.Optional.absent(),...
                'distractor', 'distractor');
            
            label2 = 'p2';
            id2 = 'id2';
            p2 = p1.insertSource(experiment,...
                datetime(),...
                datetime(),...
                protocol,...
                struct2map(struct()),...
                com.google.common.base.Optional.absent(),...
                label2, id2);
            
            p2.insertSource(experiment,...
                datetime(),...
                datetime(),...
                protocol,...
                struct2map(struct()),...
                com.google.common.base.Optional.absent(),...
                'distractor', 'distractor');
            
            label3 = 'p3';
            id3 = 'id3';
            p3 = p2.insertSource(experiment,...
                datetime(),...
                datetime(),...
                protocol,...
                struct2map(struct()),...
                com.google.common.base.Optional.absent(),...
                label3, id3);
            
            
            label4 = 'testSelectsExistingNestedSources';
            id4 = 'id4';
            [actual,isNew] = sourceForInsertion(context,...
                {label1,label2,label3,label4},...
                {id1,id2,id3,id4},...
                experiment,...
                datetime(),...
                datetime(),...
                protocol,...
                [],...
                []);
            
            assert(isNew, 'Should create a new child source');
            assertEqual(id4, char(actual.getIdentifier()));
            
            parents = asarray(actual.getParentSources());
            p = parents(1);
            assert(p.getUuid().equals(p3.getUuid()),...
                'Should have existing p3 parent');
            
            parents = asarray(p.getParentSources());
            p = parents(1);
            assert(p.getUuid().equals(p2.getUuid()),...
                'Should have existing [2 grand-parent');
            
            parents = asarray(p.getParentSources());
            p = parents(1);
            assert(p.getUuid().equals(p1.getUuid()),...
                'Should have existing p1 great-grand-parent');
            
        end
        
        % TODO id and keys  length == labels
        function testShouldRequireLabelAndIdentifierArraysBeEqualLength(self)
            context = self.context;
            import ovation.*;
            
            % Case 1
            caught = false;
            try
                sourceForInsertion(context,...
                    {'a','b','c'},...
                    {'id1','id2'},...
                    [],...
                    [],...
                    datetime(),...
                    datetime(),...
                    [],...
                    []);
            catch ex
                assertEqual(ex.identifier,...
                    'ovation:sourceForInsertion:IllegalArgument');
                caught = true;
            end
            
            assert(caught, 'Should raise exception');
            
            
            % Case 2
            caught = false;
            try
                sourceForInsertion(context,...
                    {'a','b'},...
                    {'id1','id2','id3'},...
                    [],...
                    [],...
                    datetime(),...
                    datetime(),...
                    [],...
                    []);
            catch ex
                assert(strcmp(ex.identifier,...
                    'ovation:sourceForInsertion:IllegalArgument'));
                caught = true;
            end
            
            assert(caught, 'Should raise exception');
        end
        
        function testShouldFindSourceInDistractors(self)
            import ovation.*
            ctx = self.context;
            
            label = 'type_label';
            label2 = 'type_label_2';
            idkey = 'id-key';
            idvalue = 'abc';
            distractorValue = '123';
            
            project = ctx.insertProject('unused', 'unused', datetime());
            experiment = project.insertExperiment('unused', datetime());
            protocol = ctx.insertProtocol('unused', 'unused');
            
            src = ctx.insertSource(label, idvalue);
            src.addProperty(idkey, idvalue);
            
            c = src.insertSource(experiment,...
                datetime(),...
                datetime(),...
                protocol,...
                struct2map(struct()),...
                com.google.common.base.Optional.absent(),...
                label2, idvalue);
            
            c.addProperty(idkey, idvalue);
            
            d = ctx.insertSource(label, distractorValue);
            d.addProperty(idkey, distractorValue);
            c = d.insertSource(experiment,...
                datetime(),...
                datetime(),...
                protocol,...
                struct2map(struct()),...
                com.google.common.base.Optional.absent(),...
                label2, distractorValue);
            c.addProperty(idkey, distractorValue);
            
            d = ctx.insertSource(label, distractorValue);
            d.addProperty(idkey, distractorValue);
            c = d.insertSource(experiment,...
                datetime(),...
                datetime(),...
                protocol,...
                struct2map(struct()),...
                com.google.common.base.Optional.absent(),...
                label2, distractorValue);
            c.addProperty(idkey, distractorValue);
            
            
            [~, isnew] = ovation.sourceForInsertion(ctx,...
                {label, label2},...
                {idvalue, idvalue},...
                experiment,...
                datetime(),...
                datetime(),...
                protocol,...
                [],...
                []);
            
            assertFalse(isnew);
        end
        
        function testShouldHandleNumericSourceIDs(self)
            import ovation.*;
            
            ctx = self.context;
            
            label = 'type-label';
            idvalue = 123;
            
            src = ctx.insertSource(label, num2str(idvalue));
            
            [actual,isnew] = ovation.sourceForInsertion(ctx,...
                {label},...
                {idvalue},...
                [],...
                [],...
                datetime(),...
                datetime(),...
                [],...
                []);
            
            assertFalse(isnew);
            assertJavaEqual(src.getUuid(), actual.getUuid());
        end
        
        function testShouldUseSourceInstancesInPathWithExistingChild(self)
            import ovation.*
            
            ctx = self.context;
            label = 'my-label';
            idvalue = 'my-id-value';
            
            project = ctx.insertProject('unused', 'unused', datetime());
            experiment = project.insertExperiment('unused', datetime());
            protocol = ctx.insertProtocol('unused', 'unused');
            
            s = ctx.insertSource('unused', idvalue);
            c = s.insertSource(experiment,...
                datetime(),...
                datetime(),...
                protocol,...
                struct2map(struct()),...
                com.google.common.base.Optional.absent(),...
                label, idvalue);
            
            [result,isnew] = ovation.sourceForInsertion(ctx,...
                {s, label},...
                {[], idvalue},...
                experiment,...
                datetime(),...
                datetime(),...
                protocol,...
                [],...
                []);
            
            assertFalse(isnew);
            assertJavaEqual(c.getUuid(), result.getUuid());
        end
        
        
        function testShouldUserSourceInstancesInPathWithNonExistantChild(self)
            import ovation.*;
            
            ctx = self.context;
            label = 'my-label';
            idvalue = 'my-id-value';
            
            s = ctx.insertSource('unused', 'unused');
            
            project = ctx.insertProject('unused', 'unused', datetime());
            experiment = project.insertExperiment('unused', datetime());
            protocol = ctx.insertProtocol('unused', 'unused');
            
            [result,isnew] = ovation.sourceForInsertion(ctx,...
                {s, label},...
                {[], idvalue},...
                experiment,...
                datetime(),...
                datetime(),...
                protocol,...
                [],...
                []);
            
            assertTrue(isnew);
            assertJavaEqual(result.getLabel(), java.lang.String(label));
        end
    end
end
